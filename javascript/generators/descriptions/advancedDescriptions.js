var analyseDescription = [
"GPU usage mode: 0 - none, 1 - for frame rendering. Should be used instead of \"super.gpu\" if and only if SVSuper is replaced with MSuper!",
"Direction of motion vectors to search for.<br/>1 - forward only, from current frame to the following one (not useful at all),<br/>2 - backward only, from following frame to the current one (useful only with \"smoothfps.algo: 1\"),<br/>3 - search both directions.",
"Size of a block (horizontal). It's either 8, 16 or 32. Larger blocks are less sensitive to noise, are faster, but also less accurate, smaller blocks produce more wavy picture.",
"Vertical size of a block. Default is equal to horizontal size. Additional options are: 4 for \"block.w:8\", 8 for \"block.w:16\", 16 for \"block.w:32\".",
"Block overlap value. 0 - none, 1 - 1/8 of block size in each direction, 2 - 1/4 of block size, 3 - 1/2 of block size. The greater overlap, the more blocks number, and the lesser the processing speed.Resulting overlap value in pixels should be even with CPU rendering.",
"Positive value is the number of levels used in the hierarchical analysis made while searching for motion vectors. Negative or zero value is the number of coarse levels NOT used in the hierarchical analysis made while searching for motion vectors.",
"The type of search on finest level:<br/>2 - Hexagon search, similar to x264,<br/>3 - Uneven Multi Hexagon (UMH) search, similar to x264,<br/>4 - Exhaustive search, slowest but it gives the best results.",
"Search range on finest level:<br/>0 - don't search on finest level at all, greatly increase search speed but may still looks good with GPU rendering. This option is opposite to \"super.pel\".<br/>>0 - classic fixed range in pixels.<br/><0 - \"adaptive\" range based on block local contrast. Range is small or zero for low contrast blocks (black/gray for example) but is big for blocks that has many visible details. Effective average range in common scenes is about 1/3 of this value.",
"Sort vectors from previous level by SAD values to define the order of blocks scanning so the search begins with better predictors. This option is always ON on coarse levels but may be time consuming on finest one.",
"Use SATD function instead of SAD on finest level. Extremely slow, do not use it!",
"Maximum width of a level to be processed with 'coarse' parameters. Can be useful to save CPU power when processing extra large frames (like UHD (4K)).",
"Same as 'main.search.type'.",
"Same as \"main.search.type\" except zero means \"-10\".",
"Use SATD function instead of SAD on every coarse level, improves motion vector estimation at luma flicker and fades.",
"Try to start searches around many predictors.",
"SAD threshold to define \"bad\" vectors. Value is scaled to block size 8x8.",
"The range of wide search for bad blocks. Use positive value for UMH search and negative for Exhaustive search.",
"Set the coherence of the field of vectors. The higher, the more coherent. However, if set too high, some best motion vectors can be missed.",
"penalty.lambda scaling mode between levels. 1.0 means no scaling, 2.0 - linear, 4.0 - quadratic dependence from hierarchical level number. This value is different from MVTools, see remark for explanations.",
"SAD limit for lambda using. Local lambda is smoothly decreased if SAD value of vector predictor is greater than the limit. It prevents bad predictors using but decreases the motion coherence. Value is scaled to block size 8x8.",
"Relative penalty (scaled to 256) to SAD cost for new candidate vector. New candidate vector must be better will be accepted as new vector only if its SAD with penalty (SAD + SAD*pnew/256) is lower then predictor cost (old SAD). It prevent replacing of quite good predictors by new vector with a little better SAD but different length and direction.",
"Relative penalty (scaled to 256) to SAD cost for global predictor vector (lambda is not used for global vector).",
"Relative penalty (scaled to 256) to SAD cost for zero vector. It prevent replacing of quite good predictor by zero vector with a little better SAD (lambda is not used for zero vector).",
"Relative penalty (scaled to 256) to SAD cost for up to 8 neighbours vectors.",
"Relative penalty (scaled to 256) to SAD cost for \"reverse\" vector (already found vector from reverse search direction), works only with \"analyse.vectors: 3\".",
"Only bad quality new vectors with SAD above this threshold will be re-estimated by search. Good vectors are not changed, but its SAD will be updated (re-calculated). Value is scaled to block size 8x8. Zero means \"do not refine, just divide\"",
"Same as main.search.type by default.",
"Same as super.pel value by default.",
"Same as main.search.satd by default.",
"Same as main.penalty.pnew by default.",
"Interval between analysed frames."]

var configDescription = [
"Ammount of ram to use in megabytes.",
"Ammount of threads to use",]

var smoothDescription = [
"Numerator of multiplier for frame rate change.",
"Denominator of multiplier for frame rate change.",
"If true then num/den define absolute frame rate value instead if multiplier for source frame rate.",
"Rendering algorithm or \"SVP shader\", available values are:<br/>1 - sharp picture without any blending, moves pixels by motion vectors from next frame to current. Requires only backward motion vectors (\"analyse.vectors: 2\") so it's the fastest possible method.<br/>2 - like 1st but moves pixels from the nearest (in terms of time) frame so it uses both backward and forward vectors. Recommended for 2D animations.<br/>11 - time weighted blend of forward and backward partial motion compensations.<br/>13 - same as 11th but with dynamic median added. Produces minimum artifacts but with noticeable halos around moving objects.<br/>21 - 11th plus additional cover/uncover masking to minimize halos and improve frame edges.<br/>23 - 21th plus extra vectors from adjacent frames for further decreasing of halos, can be less smooth than 21th.",
"Use block-based motion compensation instead of pixel-based. Always OFF with GPU rendering enabled.",
"Only works with GPU rendering enabled:<br/>0 - use bilinear interpolation for motion vectors and all masks,<br/>1 - use bicubic interpolation",
"Defines which video card should be used for rendering, only works with GPU rendering enabled:<br/>0 - default (use 1st available GPU),<br/>11 - use 1st GPU device on 1st OpenCL platfrom,<br/>12 - use 2nd GPU device on 1st OpenCL platfrom,<br/>21 - use 1st GPU device on 2nd OpenCL platfrom an so on.",
"Only works with GPU rendering enabled. When set to \"true\" frame rendering is done in linear light.",
"Cover/uncover mask strength, more means \"more strong mask\". Recommended values 50-100.",
"Bad areas (identified by vector's SAD values) mask, more means \"more strong mask\". Recommended value is 100, but it can dramatically reduce smoothness effect.",
"Defines the exponent of relation between SAD and area mask values.",
"Frames interpolation mode:<br/>0 - uniform interpolation for maximum smoothness. For example for 24->60 conversion output will be: \"1mmmm1mmmm...\", where \"1\" stands for original frame and \"m\" for interpolated one.<br/>1 - \"1m\" mode that gives \"1mm1m1mm1m...\" output in the above example => less artifacts at the cost of less smoothness.<br/>2 - \"2m\" mode: \"1m11m11m11...\" => much less artifacts and much less smoothness.<br/>3 - adaptive mode that switches between modes 0,1,2 based on overall vector field quality.",
"Blend frames at scene change like ConvertFps if true, or repeat last frame like ChangeFps if false.",
"Limit for changing uniform mode to \"1m\".",
"Limit for changing \"1m\" mode to \"2m\".",
"Limit for scene change detection.",
"Vectors with \"adjusted SAD\" less than this value are excluded from consideration.",
"Threshold which sets how many blocks in percents have to change.",
"Additional correction parameter for \"average luma\" value.",
"Screen aspect ratio defines black fields height (or width) and output video frame size.",
"Source video pixel aspect ratio.",
"\"Glow\" (or \"zoom out\") effect size, in percents of original frame size.",
"Lights count.",
"Flare length in percents.",
"Width of every light.",
"Height of averaging frame border."]

var superDescription = [
"The accuracy of the motion estimation. Value can only be 1, 2 or 4. 1 means a precision to the pixel, 2 means a precision to half a pixel, 4 - to quarter pixel (not recommended to use).",
"GPU usage mode: 0 - none, 1 - for frame rendering. Note that with \"gpu:1\" scaling up mode is always set to 0 cause subpixel planes are not actually used for frame rendering.",
"Turns on reduced super clip size when full=false, valid only with pel=1. It saves some memory and can be useful for processing extra large frames (like UHD (4K)).",
"Subpixel interpolation method for pel=2,4. <br/>0 for soft interpolation (bilinear),<br/> 1 for bicubic interpolation (4 tap Catmull-Rom),<br/> 2 for sharper Wiener interpolation (6 tap, similar to Lanczos).",
"Hierarchical levels smoothing and reducing (halving) filter.<br/>0 is simple 4 pixels averaging like unfiltered SimpleResize (old method);<br/>1 is triangle (shifted) filter like ReduceBy2 for more smoothing (decrease aliasing);<br/>2 is triangle filter like BilinearResize for even more smoothing;<br/>3 is quadratic filter for even more smoothing;<br/>4 is cubic filter like BicubicResize(b=1,c=0) for even more smoothing.",
"Used by the SVP Manager only. You don't need to set this in your own scripts."]